#define ROW_1 7
#define ROW_2 10
#define ROW_3 5
#define ROW_4 11
#define ROW_5 A4
#define ROW_6 4
#define ROW_7 A2  
#define ROW_8 3

#define COL_1 A3
#define COL_2 9
#define COL_3 8
#define COL_4 2
#define COL_5 6
#define COL_6 A5
#define COL_7 A1
#define COL_8 A0

const byte A[] = {
  B00000000,
  B01100000,
  B10010000,
  B10010000,
  B11110000,
  B10010000,
  B10010000,
  B00000000
};
const byte B[] = {
  B00000000,
  B11100000,
  B10010000,
  B11100000,
  B10010000,
  B10010000,
  B11100000,
  B00000000
};

const byte C[] = {
  B00000000,
  B01100000,
  B10010000,
  B10000000,
  B10000000,
  B10010000,
  B01100000,
  B00000000
};

const byte D[] = {
  B00000000,
  B11100000,
  B10010000,
  B10010000,
  B10010000,
  B10010000,
  B11100000,
  B00000000
};

const byte E[] = {
  B00000000,
  B11110000,
  B10000000,
  B11110000,
  B10000000,
  B10000000,
  B11110000,
  B00000000
};

const byte F[] = {
  B00000000,
  B11110000,
  B10000000,
  B11110000,
  B10000000,
  B10000000,
  B10000000,
  B00000000
};

const byte G[] = {
  B00000000,
  B01100000,
  B10010000,
  B10000000,
  B10110000,
  B10010000,
  B01100000,
  B00000000
};

const byte H[] = {
  B00000000,
  B10010000,
  B10010000,
  B11110000,
  B10010000,
  B10010000,
  B10010000,
  B00000000
};

const byte I[] = {
  B00000000,
  B11110000,
  B01000000,
  B01000000,
  B01000000,
  B01000000,
  B11110000,
  B00000000
};

const byte J[] = {
  B00000000,
  B00010000,
  B00010000,
  B00010000,
  B00010000,
  B10010000,
  B01100000,
  B00000000
};

const byte K[] = {
  B00000000,
  B10010000,
  B10100000,
  B11000000,
  B10100000,
  B10010000,
  B10010000,
  B00000000
};

const byte L[] = {
  B00000000,
  B10000000,
  B10000000,
  B10000000,
  B10000000,
  B10000000,
  B11110000,
  B00000000
};

const byte M[] = {
  B00000000,
  B10010000,
  B11110000,
  B10010000,
  B10010000,
  B10010000,
  B10010000,
  B00000000
};

const byte N[] = {
  B00000000,
  B10010000,
  B10010000,
  B11010000,
  B10110000,
  B10010000,
  B10010000,
  B00000000
};

const byte O[] = {
  B00000000,
  B01100000,
  B10010000,
  B10010000,
  B10010000,
  B10010000,
  B01100000,
  B00000000
};

const byte P[] = {
  B00000000,
  B11100000,
  B10010000,
  B11100000,
  B10000000,
  B10000000,
  B10000000,
  B00000000
};

const byte Q[] = {
  B00000000,
  B01100000,
  B10010000,
  B10010000,
  B10010000,
  B10010000,
  B01100000,
  B00010000
};

const byte R[] = {
  B00000000,
  B11100000,
  B10010000,
  B11100000,
  B10100000,
  B10010000,
  B10010000,
  B00000000
};

const byte S[] = {
  B00000000,
  B01100000,
  B10010000,
  B01000000,
  B00100000,
  B10010000,
  B01100000,
  B00000000
};

const byte T[] = {
  B00000000,
  B11110000,
  B01100000,
  B01100000,
  B01100000,
  B01100000,
  B01100000,
  B00000000
};

const byte U[] = {
  B00000000,
  B10010000,
  B10010000,
  B10010000,
  B10010000,
  B10010000,
  B01100000,
  B00000000
};

const byte V[] = {
  B00000000,
  B10010000,
  B10010000,
  B10010000,
  B10010000,
  B01100000,
  B01100000,
  B00000000
};

const byte W[] = {
  B00000000,
  B10010000,
  B10010000,
  B10010000,
  B10010000,
  B11110000,
  B10010000,
  B00000000
};

const byte X[] = {
  B00000000,
  B10010000,
  B10010000,
  B01100000,
  B01100000,
  B10010000,
  B10010000,
  B00000000
};

const byte Y[] = {
  B00000000,
  B10010000,
  B10010000,
  B01100000,
  B01100000,
  B01100000,
  B01100000,
  B00000000
};

const byte Z[] = {
  B00000000,
  B11110000,
  B00010000,
  B00100000,
  B01000000,
  B10000000,
  B11110000,
  B00000000
};

const byte zero[] = {
  B00000000,
  B01100000,
  B10010000,
  B10110000,
  B11010000,
  B10010000,
  B01100000,
  B00000000
};

const byte one[] = {
  B00000000,
  B11100000,
  B01100000,
  B01100000,
  B01100000,
  B01100000,
  B11110000,
  B00000000
};

const byte two[] = {
  B00000000,
  B01100000,
  B10010000,
  B00100000,
  B01000000,
  B10000000,
  B11110000,
  B00000000
};

const byte three[] = {
  B00000000,
  B01100000,
  B10010000,
  B00100000,
  B00010000,
  B10010000,
  B01100000,
  B00000000
};

const byte four[] = {
  B00000000,
  B00010000,
  B00110000,
  B01010000,
  B11110000,
  B00010000,
  B00010000,
  B00000000
};

const byte five[] = {
  B00000000,
  B11110000,
  B10000000,
  B11100000,
  B00010000,
  B10010000,
  B01100000,
  B00000000
};
//ayam masak kucing ndan anmjing

const byte six[] = {
  B00000000,
  B01100000,
  B10010000,
  B10000000,
  B11100000,
  B10010000,
  B01100000,
  B00000000
};

const byte seven[] = {
  B00000000,
  B11110000,
  B00010000,
  B00100000,
  B00100000,
  B01000000,
  B10000000,
  B00000000
};

const byte eight[] = {
  B00000000,
  B01100000,
  B10010000,
  B01100000,
  B10010000,
  B10010000,
  B01100000,
  B00000000
};

const byte nine[] = {
  B00000000,
  B01100000,
  B10010000,
  B01110000,
  B00010000,
  B00100000,
  B10000000,
  B00000000
};

const byte dot[] = {
  B00000000,
  B00000000,
  B00000000,
  B00000000,
  B00000000,
  B00000000,
  B10000000,
  B00000000
};

const byte comma[] = {
  B00000000,
  B00000000,
  B00000000,
  B00000000,
  B00000000,
  B01000000,
  B11000000,
  B00000000
};

const byte excMark[] = {
  B00000000,
  B10000000,
  B10000000,
  B10000000,
  B10000000,
  B00000000,
  B10000000,
  B00000000
};

const byte space[] = {
  B00000000,
  B00000000,
  B00000000,
  B00000000,
  B00000000,
  B00000000,
  B00000000,
  B00000000
};

// struct which store the letter and the position of the letter in the matrix
struct matrix
{
  char letter;
  int position1;
};

const byte rows[] = {
    ROW_1, ROW_2, ROW_3, ROW_4, ROW_5, ROW_6, ROW_7, ROW_8
};
const byte col[] = {
  COL_1,COL_2, COL_3, COL_4, COL_5, COL_6, COL_7, COL_8
};

void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600);

  for (byte i = 2; i <= 11; i++)
      pinMode(i, OUTPUT);
  pinMode(A0, OUTPUT);
  pinMode(A1, OUTPUT);
  pinMode(A2, OUTPUT);
  pinMode(A3, OUTPUT);
  pinMode(A4, OUTPUT);
  pinMode(A5, OUTPUT);

}
void loop() {
  // put your main code here, to run repeatedly:
  // read string from serial monitor input and store in s1
  String s1 = Serial.readString();// s1 is String type variable.
  
  s1.remove(s1.length()-1); //remove the newline character from the string
  if(s1.length()>0)
    displayText(s1);  //  display text on the led matrix only when s1 has value
}

void displayText(String str)
{
  matrix character[str.length()]; // array of matrix which hold the letter and its position in matrix e.g. {{'a',0}, {'b',5}, {'c',10}}

  for(int i=0; i<str.length(); i++) //  loop through each character in the string
  {
    character[i] = {str[i], i*5+8}; //  store the characters and its matrix position in matrix array
                                    //  i*5+8 is the position. next character must be shifted by (its index x 5)+8 
  }
    while(character[str.length()-1].position1>-4) // led matrix will stop displaying when the last character of the string is at index -4
  {
    byte onMatrixBits[8]= {B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000}; //  the bit matrix that will be displayed on led matrix
    for(int i=0; i<str.length(); i++) // loop through each character
    {
      if(character[i].position1>-3 && character[i].position1<8) // position whereby the character must appear on the matrix (position between -3 and 8)
      {
        byte *charMatrix= charToMatrix(character[i].letter);  // convert char to matrix formed character
        for(int j=0; j<8; j++)
        {
          // this is where magic happens
          // jk, this is where the character will be mapped into the led matrix
          if(character[i].position1<0)
            onMatrixBits[j] = onMatrixBits[j] | charMatrix[j] << abs(character[i].position1); // if position is less than 0, shift left
          else onMatrixBits[j] = onMatrixBits[j] | charMatrix[j] >> character[i].position1;   // if position is more than 0, shif right
        }
      }
      character[i].position1 -= 1;  // update position, because the text is scrolling to the left
    }
    int counter = 0;
    // counter is used to delay the display. otherwise you wont be able to read it because it is too fast
    while(counter<80)
    {
      printOnMatrix(onMatrixBits);   //display on the led matrix
      counter++;
    }
    
  }
}

byte* charToMatrix(char c)
{
  switch(c)
  {
    case 'A':
    case 'a':
      return A;
      break;
    case 'B':
    case 'b':
      return B;
      break;
    case 'C':
    case 'c':
      return C;
      break;
    case 'D':
    case 'd':
      return D;
      break;
    case 'E':
    case 'e':
      return E;
      break;
    case 'F':
    case 'f':
      return F;
      break;
    case 'G':
    case 'g':
      return G;
      break;
    case 'H':
    case 'h':
      return H;
      break;
    case 'I':
    case 'i':
      return I;
      break;
    case 'J':
    case 'j':
      return J;
      break;
    case 'K':
    case 'k':
      return K;
      break;
    case 'L':
    case 'l':
      return L;
      break;
    case 'M':
    case 'm':
      return M;
      break;
    case 'N':
    case 'n':
      return N;
      break;
    case 'O':
    case 'o':
      return O;
      break;
    case 'P':
    case 'p':
      return P;
      break;
    case 'Q':
    case 'q':
      return Q;
      break;
    case 'R':
    case 'r':
      return R;
      break;
    case 'S':
    case 's':
      return S;
      break;
    case 'T':
    case 't':
      return T;
      break;
    case 'U':
    case 'u':
      return U;
      break;
    case 'V':
    case 'v':
      return V;
      break;
    case 'W':
    case 'w':
      return W;
      break;
    case 'X':
    case 'x':
      return X;
      break;
    case 'Y':
    case 'y':
      return Y;
      break;
    case 'Z':
    case 'z':
      return Z;
      break; 
    case '0':
      return zero;
      break;
    case '1':
      return one;
      break;
    case '2':
      return two;
      break;
    case '3':
      return three;
      break;
    case '4':
      return four;
      break;
    case '5':
      return five;
      break;
    case '6':
      return six;
      break;
    case '7':
      return seven;
      break;
    case '8':
      return eight;
      break;
    case '9':
      return nine;
      break;
    case '.':
      return dot;
      break;
    case ',':
      return comma;
      break;
    case '!':
      return excMark;
      break;
    case ' ':
      return space;
      break;    
    default:
      break;
  }
}

void printOnMatrix(byte b[])
{
  for(int i=0; i<8; i++)
  {
    digitalWrite(rows[i], HIGH);
    for(int j=0; j<8; j++)
    {
      digitalWrite(col[j], (~b[i] >> j) & 0x01);
      digitalWrite(col[j], 1);
    }
    digitalWrite(rows[i], LOW);
  }
}
